#include "model.h"

double Model::stimulus(double _t) const {
	if(_t <= 0.0)
	{
		return 0;
	}
	return 100.0;
}

void Model::operator() (const state_type &_y, state_type &_dydt, double t) const {
/*      ydot(1) = (stim(1)/(1+stim(1)))*(par(1)-y(1)) * (1)/(1+y(4)/par(2)) - par(3)*y(3);
        ydot(2) = ((y(1)/par(4))/(1+y(1)/par(4)))*(par(5)-y(2)-y(3)) - par(6)*y(2) - par(7)*y(2);
        ydot(3) = par(7)*y(2) - par(8)*y(3);
        ydot(4) = (par(9)*y(3)/par(10))/(1 + y(3)/par(10)) - par(11)*y(4);
*/
/*        _dydt[0] = (stimulus(_t)/(1+stimulus(_t)))*(p[0]-_y[0]) * (1)/(1+_y[3])/p[1] - p[2]*_y[2];
        _dydt[1] = ((_y[0]/p[3])/(1+_y[0]/p[3]))*(p[4]-_y[1]-_y[2]) - p[5]*_y[1] - p[6]*_y[1];
        _dydt[2] = p[6]*_y[1] - p[7]*_y[2];
        _dydt[3] = (p[8]*_y[2]/p[9])/(1 + _y[2]/p[9]) - p[10]*_y[3];
*/
 	_dydt[0] =  - _y[0]*p[2] - (stimulus(t)*(_y[0] - p[0]))/((stimulus(t) + 1)*(_y[3]/p[1] + 1));
	_dydt[1]  =  - _y[1]*p[5] - _y[1]*p[6] - (_y[0]*(_y[1] + _y[2] - p[4]))/((_y[0]/p[3] + 1)*p[3]);
	_dydt[2] =  _y[1]*p[6] - _y[2]*p[7];
	_dydt[3] =  (pow((_y[2]/p[9]),p[11])*p[8])/(pow((_y[2]/p[9]),p[11]) + 1) - _y[3]*p[10];
}


matrix_type Model::jacobiandpar(const state_type &_y, const double t)
{
	matrix_type m(4, 12);
	m(0,0) =  stimulus(t)/((stimulus(t) + 1)*(_y[3]/p[1] + 1));
m(0,1) =  -(stimulus(t)*(_y[0] - p[0])*_y[3])/((stimulus(t) + 1)*pow((_y[3]/p[1] + 1),2)*pow(p[1],2));
m(0,2) =  -_y[0];
m(0,3) =  0;
m(0,4) =  0;
m(0,5) =  0;
m(0,6) =  0;
m(0,7) =  0;
m(0,8) =  0;
m(0,9) =  0;
m(0,10) =  0;
m(0,11) =  0;
m(1,0) =  0;
m(1,1) =  0;
m(1,2) =  0;
m(1,3) =  (_y[0]*(_y[1] + _y[2] - p[4]/1))/((_y[0]/p[3] + 1)*pow(p[3],2)) - (pow(_y[0],2)*(_y[1] + _y[2] - p[4]/1))/(pow((_y[0]/p[3] + 1),2)*pow(p[3],3));
m(1,4) =  _y[0]/(1*(_y[0]/p[3] + 1)*p[3]);
m(1,5) =  -_y[1];
m(1,6) =  -_y[1];
m(1,7) =  0;
m(1,8) =  0;
m(1,9) =  0;
m(1,10) =  0;
m(1,11) =  0;
m(2,0) =  0;
m(2,1) =  0;
m(2,2) =  0;
m(2,3) =  0;
m(2,4) =  0;
m(2,5) =  0;
m(2,6) =  _y[1];
m(2,7) =  -_y[2];
m(2,8) =  0;
m(2,9) =  0;
m(2,10) =  0;
m(2,11) =  0;
m(3,0) =  0;
m(3,1) =  0;
m(3,2) =  0;
m(3,3) =  0;
m(3,4) =  0;
m(3,5) =  0;
m(3,6) =  0;
m(3,7) =  0;
m(3,8) =  pow((_y[2]/p[9]),p[11])/(pow((_y[2]/p[9]),p[11]) + 1);
m(3,9) =  (pow((_y[2]/p[9]),p[11])*pow((_y[2]/p[9]),(p[11] - 1))*_y[2]*p[8]*p[11])/(pow(p[9],2)*pow((pow((_y[2]/p[9]),p[11]) + 1),2)) - (pow((_y[2]/p[9]),(p[11] - 1))*_y[2]*p[8]*p[11])/(pow(p[9],2)*(pow((_y[2]/p[9]),p[11]) + 1));
m(3,10) =  -_y[3];
m(3,11) =  (log(_y[2]/p[9])*pow((_y[2]/p[9]),p[11])*p[8])/(pow((_y[2]/p[9]),p[11]) + 1) - (log(_y[2]/p[9])*pow((_y[2]/p[9]),(2*p[11]))*p[8])/pow((pow((_y[2]/p[9]),p[11]) + 1),2);

	return m;
}

matrix_type Model::jacobiandvar(const state_type &_y, const double t)
{
	matrix_type m(4, 4);
m(0,0) =  - p[2] - stimulus(t)/((stimulus(t) + 1)*(_y[3]/p[1] + 1));
m(0,1) =  0;
m(0,2) =  0;
m(0,3) =  (stimulus(t)*(_y[0] - p[0]))/((stimulus(t) + 1)*pow((_y[3]/p[1] + 1),2)*p[1]);
m(1,0) =  (_y[0]*(_y[1] + _y[2] - p[4]/1))/(pow((_y[0]/p[3] + 1),2)*pow(p[3],2)) - (_y[1] + _y[2] - p[4]/1)/((_y[0]/p[3] + 1)*p[3]);
m(1,1) =  - p[5] - p[6] - _y[0]/((_y[0]/p[3] + 1)*p[3]);
m(1,2) =  -_y[0]/((_y[0]/p[3] + 1)*p[3]);
m(1,3) =  0;
m(2,0) =  0;
m(2,1) =  p[6];
m(2,2) =  -p[7];
m(2,3) =  0;
m(3,0) =  0;
m(3,1) =  0;
m(3,2) =  (pow((_y[2]/p[9]),(p[11] - 1))*p[8]*p[11])/(p[9]*(pow((_y[2]/p[9]),p[11]) + 1)) - (pow((_y[2]/p[9]),p[11])*pow((_y[2]/p[9]),(p[11] - 1))*p[8]*p[11])/(p[9]*pow((pow((_y[2]/p[9]),p[11]) + 1),2));
m(3,3) =  -p[10];
	return m;

}

